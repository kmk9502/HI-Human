# 웹 해킹 유형별 탐지, 분석, 대응
# Brute Force
- ## 개념 
    사용자 인증을 통과 또는 특정 암호를 풀기 가능한 모든 값을 대입헤보는 공격. 즉 무차별 대입 공격이다. </br>웹 애플리케이션의 사용자 인증정보가 기본 값이거나 예측하기 쉬운 패스워드일 경우 공격 당하기 쉽다. 
- ## Brute Force 공격에 취약한 구조
    - ### 디폴트 패스워드 
        보안이 취약한 디폴트 패스워드, 즉 기본 패스워드를 이용하는 경우</br>
    - ### 쉬운 패스워드
        말 그대로 추측하기 쉬운 패스워드를 사용하는 경우</br>
    - ### 설계상의 인증 문제
        1. Brute Force 공격을 지연시키기 위한 패스워드 실패 시 잠금 등의 보안 설정을 하지 않았을 경우 
        2. 로그인 실패시 출력되는 오류 메시지에 로그인 정보를 유출하는 경우</br> Ex>  "패스워드가 일치하지 않습니다" = 아이디는 일치한다. 
- ## 공격 
  - ### BurpSuite
    프록시를 통해 로그인 인자 값으로 넘어가는 값을 조작하여 무차별 대입 공격을 시행하는 해킹 도구. </br>로그인 성공 여부는 html 반환 값의 길이로 판별할 수 있다.</br></br>단점: 문자열을 무작위 대입하기 때문에 시간이 오래 걸림.</br>-> 단점을 보완하기 위해 무작위가 아닌 **사전 공격**(Dictionary Attack)을 수행.

  - ### Hydra  
    프록시를 이용하여 유효한 로그인/암호 쌍을 추측 및 해킹할 수 있는 도구이며, 다양한 프로토콜 기반의 BrupSuite 공격을 지원한다. </br>Brute Force 공격에 가장 많이 사용된다. </br></br>이 도구는 
    1. 사전파일 준비 
    2. BurpSuite나 기타 도구를 활용하여 hydra에 사용될 인자 값 확인 
    3. hydra를 활용하여 Brute Force 공격 실행 단계 순으로 진행한다.

  - ### patator
     파이썬으로 제작된 Brute Force 자동화 공격 도구이며, 다양한 프로토콜 기반의 Brute Force 공격을 지원한다. </br>이 도구도 사전 파일을 먼저 생성하여 공격을 진행한다. </br>
	 이 도구는 BurpSute와 마찬가지로 반환 값의 길이로 로그인 성공 여부를 파악할 수 있다.

- ## 탐지
  - ### 요청 패킷 기반 탐지 관련 옵션_Snort
    - ### IP / Port
       클라이언트에서 인입되는 패킷을 탐지 기준으로 설정하기 때문에 도착지 IP와 Port는 각각 서버 IP, 웹 사이트가 사용하는 포트로 설정한다.

    - ### Content
       Brute Force 공격을 시도하면 특정 HTTP URL이 짧은 시간 내에 다수 호출된다는 것을 이용하여 탐지 조건 설정을 진행한다. </br>예시로 패킷의 페이로드 전체에서 해당되는 문자열을 찾는 등의 조건 설정을 들 수 있다.

    - ### flow_control
       IDS/IPS로 인입되는 패킷의 방향을 설정하기 위해 flow_control 옵션을 사용한다. </br>flow_control은 패킷의 방향과 연결 형태를 의미한다. 이를 이용해 요청 패킷과 응답 패킷을 구분짓는다.

    - ### detection_filter
       임계치 기반으로 탐지가 가능한 옵션이다. Brute Force 공격은 짧은 시간에 많은 패킷이 서버로 들어가기 때문에, 임계치 기반으로 탐지를 설정해야 한다. </br>이 옵션은 IP가 출발/도착지인지 혹은 패킷 개수와 시간에 따른 조건을 다양하게 조합해서 사용할 수 있다.</br>
	   옵션 값을 설정할 때 공격의 형태를 잘 분석해서 미탐 혹은 과탐이 발생하지 않도록 설정해야 한다.

   - ### 응답 패킷 기반 탐지 관련 옵션_Snort
     - ### IP / Port
       서버에서 클라이언트로 응답하는 패킷을 탐지 기준으로 설정하기 때문에 도착지 IP와 Port는 각각 클라이언트의 IP, 포트로 설정한다.
     - ### Content
        응답 패킷에 포함되어 있는 문자열을 탐지한다. 이때 요청 패킷 기반 탐지와 마찬가지로 시간 기준으로 패킷 개수를 탐지할 수 있도록 설정한다. </br>이 옵션 설정을 통해 특정 문자열이 특정 시간에 많이 확인된다면 Brute Force 공격을 시도하고 있음을 의심할 수 있다.
     - ### flow_control
       서버에서 클라이언트로 응답하는 패킷을 탐지하도록 옵션을 설정해야 하기 때문에 방향 설정을 '서버에서 클라이언트'로 바꿔야 한다.
     - ### detection_filter
        응답 패킷 기반으로 탐지해야하기 때문에 서버가 클라이언트에게 얼마나 짧은 시간에 많은 패킷을 전송했는지 알 수 있도록 옵션을 설정해야 한다. 

- ## 탐지 결과 
  - ### Snort 탐지
    Brute Force 공격시 요청 패킷과 응답 패킷을 살펴보면 1초마다 수십 개의 패킷이 발생하고 있는 것을 확인할 수 있다.
  - ### 네트워크 탐지
    Brute Force 공격시 네트워크 패킷을 확인하면 요청 및 응답 패킷의 프로토콜과 메소드, 그리고 Get 메소드의 경우 URL 내 admin, password 파라미터에 Brute Force 공격을 시도한 문자열을 확인할 수 있다. 
  - ### access_log
    Brute Force 공격시 access_log에는 HTTP 응답 패킷 사이즈도 기록되며 바이트 크기를 통해 로그인 성공/실패 여부를 </br>확인할 수 있다. 또한, URL의 파라미터에 공격자가 사전 대입한 문자열도 확인할 수 있다.

- ## 시각화
  -  ### 시각화 도구의 기능
     - **특정 페이지 필터링** - 특정 공격 페이지에 대한 필터링을 통해 그래프를 간략하게 표현 가능</br></br>
     - **서브 버킷 추가 및 특정 로그 필터링** - 서브 버킷을 통해 그래프를 세분화할 수 있고, 정렬 방식을 선택할 수 있다. </br>특정 로그 필터링을 통해 특정 로그만을 제외할 수 있다.</br></br>
     - **공격자 IP와 Port 분류** </br></br>
     - **특정 시간대의 공격자 IP 확인**

- ## 대응
  - ### Medium 레벨
    Medium 레벨에서는 Low 레벨에서의 취약점을 Medium 레벨에서 어떻게 보완하였는지 확인하기 위해 소스코드 비교 도구로 파일, 디렉토리 및 버전 관리된 프로젝트를 비교할 수 있도록 도와준다.</br>또한, **MySQLi_real_escape_string()** 함수가 추가되어 사용자 입력 값 중 특수문자가 포함되어 있을 경우 역슬래쉬( \ )를 붙여 일반 문자열로 변환한다.
  - ### High 레벨
    High 레벨에서는 Medium 레벨에서의 취약점을 High 레벨에서 어떻게 보완하였는지 확인할 수 있고, 크게 **checkToken()**, **stripslashes()** 적용 및 **Sleep()**, **rand()** 함수를 사용하여 지연시간을 일정 범위 내에서 무작위하게 설정하여 보안성을 강화할 수 있다.</br>또한, High 레벨에서는 Medium 레벨의 특수문자 변환은 물론 입력된 인자 값에 역슬래쉬( \ )가 있으면 이를 제거하는 **stripslashes()** 함수를 사용할 수 있다. 
  - ### Impossible 레벨
    Impossible 레벨에서는 이전 레벨에서의 대응 방법에 **HTTP** 메소드가 **GET**에서 **POST** 방식으로 변경, 데이터베이스 처리시 **PDO** 적용, 계정잠금 임계값 및 시간 설정 등이 추가되었다. </br>**PDO**란 PHP Data Objects의 약자로, **SQL**을 미리 컴파일 해두고, 파라미터 값만 바꿔서 **SQL** 쿼리를 실행하는 방법, 즉 사용자가 SQL 쿼리 조작을 하지 못하게 정해진 SQL 구문과 변경 가능한 값을 미리 만들어두는 방법을 사용하여 **SQL Injection** 방어에 효과적이다.
    </br></br></br></br></br>

# Command Injection
- ## 개념
    명령어 삽입 공격이란 사용자가 입력하는 **인자 값**을 **조작**하여 운영체제 명령을 호출하여 실행하는 공격기법이다. </br> **웹**을 통해 시스템 명령어를 실행하게 되며, 특정 명령어 실행에 성공하면 작게는 파일 정보 유출, 크게는 시스템 장악까지 가능하게 된다.
- ## 취약한 함수
  |구분|함수|
  |:--:|:---|
  |Java(Servelt, JSP)|System.*(특히 System.Runtime)</br>Runtime.exec( )|
  |C / C++|system( ), exec( ), ShellExecute( )|
  |Python|exec( ),evall( ), os.system( ), os.popen( ), subprocess.popen( ), subprocess.call|
  |Perl|open( ), sysopen( ), system( ), glob( )|
  |PHP|exec( ), system( ), passthru( ), popen( ), rquire( ), include( ), eval( ), </br>preg_replace( ), shell_exec( ), proc_open( ), eval( )|
  ||
- ## 공격
  - ### 명령어 삽입에 사용되는 명령어
    |명령어|기능|
    |:---:|:---|
    |세미콜론( ; )|하나의 라인에서 여러 명령어들을 성공 혹은 실패 여부와 상관없이 실행할 수 있다.</br>Ex> 명령 1; 명령 2; 명령 3; ...|
    |더블 엠퍼샌드( && )|하나의 라인에서 여러 명령어들을 실행시 앞의 명령어가 성공하였을 경우 다음 명령을 실행한다.</br>Ex> 명령 1 && 명령 2 && ... -> 명령 1이 성공할 경우에만 명령 2가 실행됨|
    |파이프(Shift + \ ) | 한 명령어의 결과가 다른 명령의 입력으로 지정되어 실행된다.|
    |더블 버티컬바( Shift + \ x 2) | 하나의 라인에서 여러 명령어들을 실행시 앞의 명령어가 실패하더라도 다음 명령을 실행한다.
    ||
  - ### Low 레벨
    공격하고자 하는 서버가 입력값의 특수문자를 필터링하지 않는 경우.</br>
  - ### Medium 레벨
    공격하고자 하는 서버가 몇몇 특수문자만 필터링하는 경우.
  - ### High 레벨
    공격하고자 하는 서버가 모든 특수문자를 필터링하는 경우. </br>High 레벨에서는 필터링되는 문자의 **허점**(개발자들의 실수 가능성 등)을 찾는다. 
- ## 탐지
  - ### 세미콜론을 포함한 시스템 명령 탐지_Low 레벨
      - ### IP / Port
        서버로 향하는 패킷 기준으로 도착지 IP / PORT를 설정해서 클라이언트에서 서버로 전송되는 패킷을 탐지한다.
      - ### Content  
         HTTP 헤더 내 쿠키 값에 low 문자열이 존재하는지 확인하는 Rule을 설정한다.
      - ### Pcre
        URL 인코딩된 세미콜론을 탐지하기 위한 정규표현식을 작성한다.
      - ### flow_control
        snort에서 외부 IP와 시스템 명령어 패턴을 입력하는 요청 패킷을 탐지하기 위해 서버로 향하는 패킷을 탐지하도록 설정한다.
  - ### 파이프를 포함한 시스템 명령 탐지_Medium 레벨
    - ###  IP / Port
      서버로 향하는 패킷 기준으로 도착지 IP / PORT를 설정해서 클라이언트에서 서버로 전송되는 패킷을 탐지한다.
    - ### Content  
      HTTP 헤더 내 쿠키 값에 Medium 문자열이 존재하는지 확인하는 Rule을 설정한다.
    - ### Pcre
      IP의 피리어드( . )와 숫자 패턴을 정규식으로 표현하고 세미콜론을 포함한 시스템 명령 탐지 Rule과 마찬가지로 파이프 및 앰퍼센트( & )와 같은 특수문자를 매칭하기 위해 **hex** 코드를 탐지 조건으로 설정한다. 
    - ### flow_control
      snort에서 외부 IP와 시스템 명령어 패턴을 입력하는 요청 패킷을 탐지하기 위해 서버로 향하는 패킷을 탐지하도록 설정한다.
  - ### 시스템 명령 탐지_High 레벨
    - ### 허점
      파이프 뒤에 시스템 명령을 입력하면 바로 실행이 가능하다.  
    - ### IP / Port
      서버로 향하는 패킷 기준으로 도착지 IP / PORT를 설정해서 클라이언트에서 서버로 전송되는 패킷을 탐지한다.
    - ### Content  
      HTTP 헤더 내 쿠키 값에 High 문자열이 존재하는지 확인하는 Rule을 설정한다.
    - ### Pcre
      정규표현식을 사용하지 않고, 파이프 뒤에 시스템 명령어가 오는 것을 탐지한다. 파이프를 탐지조건으로 설정하기 위해 **hex** 코드를 탐지조건으로 설정한다. 그리고 http의 body 부분을 탐지할 수 있게 설정한다. 
    - ### flow_control
      snort에서 외부 IP와 시스템 명령어 패턴을 입력하는 요청 패킷을 탐지하기 위해 서버로 향하는 패킷을 탐지하도록 설정한다.
- ## 시각화
  - ### access_log의 Byte Code 사이즈 비교를 통한 공격여부 추정
    Command Injection 공격의 경우 access_log에는 POST 메소드가 기록되어 http body 영역의 데이터가 보이지 않는다.</br> 하지만 공격의 특성 상 
    1. 명령어가 삽입되어 실행되어야 하는 점 
    2. 실행에 대한 결과가 반환되는 점 (성공, 실패, 응답 없음 등)
    3. 명령어에 따라 전송되는 Byte에 차이가 있는 점 </br>
   
    등을 고려하여 byte 기반으로 데이터 분석을 통해 시각화를 진행한다. 

- ## 대응
  - ### Medium 레벨
    Low 레벨과 다르게 **블랙리스트**를 설정할 수 있다. 정상적인 명령어 뒤에 임의의 명령어가 실행되지 않도록 필터링 값을 입력할 수 있다.
      - str_replace() 함수를 통해 문자열을 치환하여 값을 필터링 할 수 있다.
  - ### High 레벨 
    Midium 레벨의 앰퍼샌드( & )와 세미콜론( ; )에서 추가로 7개를 더해 총 9가지의 문자를 치환한다. 
    - trim() 함수를 통해 공백 또는 문자를 제거할 수 있다.
  - ### Impoassible 레벨
    사용자의 입력이 본래의 목적에 맞는 값인지 유효성을 검증한다. </br>Ex> IP 형태의 인자 값만 처리하고 나머지는 필터링한다.
      - ### 세션 토큰 검증
        checkToken() 함수를 호출하여 **CSRF** 공격을 예방한다. 
      - ### stripslashes()를 통한 문자열 필터링
        stripslashes() 함수로 **역슬래쉬**( \ )를 제거한다.
      - ### explode()를 통한 IP 구분
        explode() 함수를 통해 $target의 값을 피리어드( . )를 기준으로 **분배**해서 $octet에 저장한다.
      - ### IP 형태 검증(is_numeric() 및 sizeof() 사용)
        is_numeric() 함수를 이용해 $octet의 각 배열 값이 **정수형**인지 확인하고 sizeof() 함수를 통해 $octet 배열의 갯수가 특정 값이라면 조건에 맞는 라인을 **실행**한다. </br>
        그리고 $octet 각 배열 요소를 피리어드( . )로 구분하고 IP 주소형태로 $target 변수에 저장한다.
        </br></br>* is_numeric() 함수는 숫자면 TRUE를 반환하고 숫자가 아니면 FALSE를 반환한다. 그리고 sizeof() 함수는 배열 요소의 개수를 계산한다. 