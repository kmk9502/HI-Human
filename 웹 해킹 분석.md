# HTTP 동작원리

- 웹을 구성하기 위한 3가지 핵심요소: **HTML**, **HTTP**, **URL**

### **가. HTML**

- 정의: <br/>웹 문서를 작성하는 표준 마크업(Markup Language)이다.
- 특징:<br/>**태그**(tag)라는 명령어를 사용하여 개발자가 원하는 형태의 문서 / 그림을 구성할 수 있다.<br/>'<', '>'를 사용하여 태그를 구성한다.<br/>HTML 문서는 최상위 태그로 < html >을 사용한다.<br/>< head >태그는 **문서를 정의**하는 데이터를 포함한다.<br/>< body >태그는 문서의 내용을 작성할 수 있는 태그이다.<br/>파일 확장자는 ***.html** 또는 ***htm**을 사용한다. 이 두 확장자 파일을 웹 브라우저에서 로딩하면 웹 페이지를 확인할 수 있다.

### **나. HTTP**

- 정의:<br/>웹 서버와 클라이언트(웹 브라우저) 간의 문서 및 데이터를 교환하기 위한 **통신 규약**을 의미한다. <br/>즉, **HTML** 문서와 같은 자원(리소스)을 처리하는 프로토콜로 웹 서버와 클라이언트 간 데이터 교환의 기초가 된다.<br/><br/>
- 특징:<br/> 
  - **1) 비연결지향**<br/>그때그때 할 말만 하고 마는 관계이다. <br/>클라이언트가 HTTP 요청을 서버로 보내면, 서버는 클라이언트 요청에 맞는 응답을 보내고 접속을 끊는다. 즉, 서버가 계속해서 연결되어 있지 않다.<br/><br/>
  - **2) 상태정보 유지안함**<br/>구조적인 한계로 인해 클라이언트와 서버와의 통신이 끝나면 상태 정보는 유지하지 않는 것이다. <br/>대신 서버는 쿠키와 세션을 사용해 클라이언트를 식별하게 된다.<br/><br/>
    - **가) 쿠키와 세션**<br/>**신분증**과 비슷한 **쿠키**는 클라이언트에 저장되는 키와 값들의 작은 데이터 조각을 의미하며, 이름 / 값 / 만료날짜 / 경로 등의 정보가 포함되어 있다. 일정 시간동안 데이터를 저장할 수 있으며, 클라이언트의 상태 정보를 로컬에 저장하고 참조한다. <br/><br/>
      - **HTTP는 사용자를 기억하지 못한다.** 따라서 서버가 사용자를 기억하기 위해 **쿠키**라는 영수증을 만들었다. <br/><br/>예를 들어 어느 웹 사이트에서 언어 설정을 KR(한국어)로 설정을 요청했다면 그 웹 사이트는 나에게 '이 사용자는 KR 언어를 사용한다'라는 쿠키를 보낸다. 이후 다시 그 사이트에 접속하면 브라우저는 서버에 쿠키를 전달하고 서버는 요청을 받아들여 KR로 번역된 페이지를 출력한다.<br/>
          - **쿠키의 규칙**: <br/>**1**. **1개 도메인에 한정**된다. 즉, 페이스북이 생성한 쿠키는 페이스북에서만 사용 가능. 넷플릭스 등으로 보낼 수 없다. <br/>**2**. 쿠키들은 자동으로 클라이언트로 보내진다. 즉, 서버는 원하는만큼 쿠키를 보낼 수 있고, 브라우저는 자동으로 쿠키를 저장한다.<br/>**3**. 자동으로 세팅이 된다. 사용자는 이것에 간섭할 수 없다.<br/>
      - 그러나 실제 웹 사이트가 전송하는 쿠키를 확인하면 접속한 웹사이트에 대한 쿠키 외에 다른 쿠키들이 전송되는 것을 볼 수 있는데, 이론적으로는 해당 사이트의 쿠키만 받아야 한다. <br/>하지만 해당 웹 페이지에 **다른 웹 페이지로 통하는 링크**가 있다면 브라우저는 링크된 웹 페이지에도 쿠키를 요청하게 되고 쿠키를 받아온다. <br/>이것이 1개 웹 페이지에 여러 사이트의 쿠키가 섞여있는 이유다.
    
            쿠키의 생성 및 사용
            
            1. 클라이언트가 브라우저로 웹 페이지에 접속
            2. 서버는 클라이언트가 요청한 웹 페이지를 처리하고 쿠키를 클라이언트에 파일로 저장
            3. 클라이언트는 서버에 재요청 시 쿠키정보를 활용해서 서버에 전달
            4. 서버는 클라이언트의 쿠키를 활용하여 상태 정보를 유지할 수 있도록 처리

        **세션**은 쿠키와 다르게 서버의 메모리에 저장되는 정보이다. <br/> 일정 시간동안 웹 브라우저를 통해 들어오는 요청을 하나의 상태로 보고 유지하는 기술이다. 즉, 사용자가 웹 브라우저를 통해 사이트에 접속하게 되면 **브라우저를 종료할 때까지** 로그인 유지와 같은 상태가 지속된다.

            세션의 생성 및 사용

            1. 클라이언트가 서버의 웹 페이지에서 로그인 시도
            2. 서버는 클라이언트가 요청한 로그인 정보가 맞을 경우, 서버 메모리에 세션ID를 생성하고 클라이언트의 ID와 매핑된 정보를 저장
            3. 클라이언트는 세션ID를 쿠키로 저장
            4. 클라이언트가 요청할 때마다 서버는 쿠키정보를 확인하고 세션ID와 매핑되는 ID를 사용자로 인증

    - **나) 히든 필드**<br/>히든 필드는 사용자가 보거나 수정할 수 없도록 개발자가 웹페이지의 폼(Form)을 통해 데이터를 전솧하는 것이다. **GET 또는 POST** 메소드를 통해 웹 서버에 전달된다.

### **다. URI / URL / URN**

- **URI**<br/><br/>
  -   정의: <br/>URI는 인터넷의 우편물의 발송지 주소 같은 개념으로, 인터넷에 존재하는 리소스를 고유하게 식별하고 위치를 지정하는 표기법(규약)이다. URI는 URL과 URN을 모두 포함하는 개념이다.<br/><br/>
- **URL**<br/><br/>
    - 정의:<br/>URL은 인터넷 상 가용한 자원에 대해 문자(열)로 표현하는 것을 의미하며, 클라이언트가 서버로 **HTTP** 프로토콜을 통해 접속하기 위한 **경로**이다.<br/><br/>
    - 특징:<br/>**프로토콜의 종류에 따라 URL 표기 방식이 달라진다.** <br/>Ex> FTP의 경우 "ftp://id:pass@host:port/path"의 형태로 표현이 가능. <br/>프로토콜을 설정할 수 있는 HTML 명령어는 스키마(Scheme)이다. <br/>URL을 통해 자원(리소스)이 어디에 위치하고 어떻게 접근할 수 있는지 알 수 있다.

- **URN**<br/><br/>
  - 정의:<br/>URN은 지속적이면서 특정 위치의 독립적인 자원(리소스)을 가리키기 위한 특별한 지시자이다. <br/>Ex> 도서번호, 주민등록번호 등 무언가를 특별하게 구분할 수 있게 하는 것.

### **라. HTTP 메시지**

  ### **1) 요청 메시지 구성**
  - **Request Line**<br/><br/>
    - 정의:<br/> **HTTP 메소드**, 클라이언트가 요청하는 **Request URI**, **HTTP 버전**으로 구성되어 있다.<br/><br/> **HTTP 메소드**는 키워드 또는 메시지와 같은 개념으로 클라이언트가 웹서버에게 사용자 요청을 하기 위해 요청 목적이나 종류를 알리는 수단을 의미한다. <br/>Ex> GET, POST, HEAD, PUT, DELETE, TRACE, OPTIONS, CONNECT, 벤더 사의 필요에 의해 정의된 메소드 등<br/><br/>**Request URI**는 요청할 자원 정보를 식별하는데 사용한다. <br/>Ex> "*", absoluteURI, abs_path, authority의 4가지 옵션<br/><br/>
- **Request Headers**<br/><br/>
  - 정의:<br/>HTTP에서 Header는 General, Request, Entity의 3가지로 구분한다.<br/>Request Header는 클라이언트가 요청 및 클라이언트 자체에 대한 추가 정보를 웹 서버에 전달할 수 있게 한다. 요청 패킷의 주요 Request Header 내용은 다음과 같다.

| 구분 | 내용 |
|:----:|:-----|
|Host|클라이언트가 요청한 서버 정보|
|User-Agent|클라이언트 브라우저의 이름, 버전|
|Accept|클라이언트가 허용할 수 있는 파일 형식(MIME-TYPE)|
|Referrer|현재 페이지가 어떤 웹 페이지에서 요청되었는지에 대한 정보|
|Accept-Encoding|클라이언트가 인식할 수 있는 인코딩 형식|
|Accept-Language|클라이언트가 인식할 수 있는 언어|

  - **Message Body**<br/><br/>
    - HTTP 메소드가 POST인 경우 HTTP Body 영역에 데이터를 넣어서 전송한다. <br/>GET 메소드는 URL에 데이터를 실어서 전달하기 때문에 HTTP Body 영역에는 아무것도 존재하지 않게 된다.

### **2) 응답 메시지 구성**
- **Status Line**<br/><br/>
  - 구성:<br/><br/>
    - **HTTP 버전**:<br/>HTTP 버전은 현재까지 1.0, 1.1, 2.0으로 구분된다. <br/>1.0 버전은 1996년에 최초 발표되어 요청 및 응답 규약 및 상태 코드에 대해서 정의되었다.<br/>1.1 버전은 Option, Dellete, Trace 등 일부 메소드를 확장하여 사용하였으며, 통신 효율을 위해 캐싱 제어 기법을 구체화하였다. <br/>2.0 버전은 구글에서 제안한 SPDY 프로토콜을 기반으로 제정되었으며, HTTP 1.1과 높은 호환성을 제공한다.<br/><br/>
    - **상태 코드**:<br/>상태 코드는 3자리 수의 정수로 구성된 결과 코드이며 HTTP 요청에 대한 응답의 결과가 모두 코드로 사전에 정의되어 있다. <br/><br/>
    - **이유 구문**:<br/>이유 구문은 사용자가 이해할 수 있도록 상태 코드에 대한 간단한 설명이 기술되어 있다. 상태 코드의 1번째 숫자는 응답 클래스를 의미한다. <br/>이렇듯 상태 코드에 의해 서버의 응답 결과를 확인함으로써 서버의 설정 또는 요청의 정상 유무 등을 알 수 있으며, 이를 통해 유지보수 또는 취약점 공격 등이 가능핟다.

|응답 클래스|내용|설명|
|:--------:|:--:|:--|
|1XX|조건부 응답|요청 수신, 계속 처리|
|2XX|성공|작업이 성공적으로 처리됨|
|3XX|리다이렉션 완료|다음 작업을 수행. 요청한 페이지를 다른 페이지로 대체|
|4XX|요청 오류|클라이언트의 요청에 잘못된 구문이 포함되었거나 요청할 수 없음|
|5XX|서버 오류|서버가 유효한 요청을 수행하지 못함|

- **Response Header**<br/><br/>
  - 정의: <br/>Request-URI에 의해 식별되어 추가적으로 접근을 하고자 하는 자원과 서버에 대한 정보를 제공한다.<br/><br/>
  - 특징:<br/>**Accept-Ranges**는 서버가 자원에 대한 범위 요청을 얼만큼 수락할지 정하는 변수이다.<br/><br/>**ETag**는 요청한 변화에 대한 Entity 태그의 현재 값을 제공하며, HTTP 컨텐츠 변경 유무를 검사하는데 사용한다. 컨텐츠가 변동되지 않았다면 **HTTP 304**(수정되지 않음)를 반환하고, 변동되었다면 전체 응답을 전송한다. 서버는 요청을 처리하기 위해 서버에 사용되는 소프트웨어에 대한 정보를 포함한다. 즉, 웹서버 정보가 표시된다.<br/><br/>**Vary**는 클라이언트와 서버 사이의 캐싱을 위해 필요한 필드이다.<br/>서버의 성능 부하를 줄이기 위해 서버가 수신한 데이터 중간의 캐시에 저장된 데이터를 반환하는데 <br/>Vary는 반환 여부를 결정하는 역할을 수행한다.

|구분|내용|
|:--:|:---|
|Accept-Ranges|서버가 자원에 대한 범위 요청을 수락함|
|Age|발신자의 서버에서 응답(또는 재검증)이 생성된 이후 발신자에게 응답 예상시간을 전달함|
|ETag|요청된 변화에 대해 Entity 태그의 현재 값을 제공|
|Location|응답을 재전송 시 목적지를 가리킴|
|Proxy-Authenticate|407(프록시 인증 필요) 응답의 일부로 포함됨|
|Retry-After|503(서비스 불가)응답과 함께 사용가능하며 요청 클라이언트가 서비스를 사용할 수 없는 예상기간을 나타냄|
|Server|사용 중인 웹서버 정보를 제공|
|Vary|캐시 재검증 없이 후속요청에 응답하는 것에 대한 여부를 결정 + 위의 특징|
|WWW-Authenticate|401(인가되지 않음) 응답 메시지에 포함|
||

### **마. HTTP 관련 언어/기술**

  ### **1) 자바스크립트(JavaScript)**
- 정의:<br/>자바스크립트는 **웹 페이지와 상호작용** 할 수 있도록 만들어진 스크립트 언어이다.<br/><br/>
- 기능:<br/>1. 웹 페이지 코딩에서 사용자와의 직접적인 이벤트 처리<br/>2. 이미지를 동적으로 보이도록 만듬<br/>3. node.js 프레임워크를 이용해 자바스크립트로 서버 사이드 기술을 제어 가능<br/><br/>
- 자바와 자바스크립트의 차이점

|구분|자바|자바스크립트|
|:--:|:--:|:---------:|
|개발사|선(Sun)에서 개발|넷스케이프에서 개발|
|   |객체지향 언어|프로토타입 기반의 스크립트 언어|
|   |변수 자료형 선언필요|변수 자료형 선언 없음|
|특징|컴파일이 필요|컴파일 필요 없이 실행(인터프리터)|
|   |정적형|동적형(HTML, 상호작용성과 동적 시각효과를 표현)|
|   |디스크 접근 가능|디스크 접근 불가(파일 입출력 등)|
|용도|네트워크/DB/웹/애플릿/스마트폰 프로그래밍 등|웹 프로그래밍|
|파일 확장자|java|.js|
|   |

  - **가) 웹 개발**<br/><br/>
    - 현재 웹 사이트가 동작하는데 있어서 자바스크립트의 역할이 상당히 큰 편이다.<br/><br/>
  - **나) 서버 개발**<br/><br/>
    - **Node.js**의 등장으로 인해 자바스크립트가 서버 사이드 개발까지 가능하게 되었다. <br/><br/>
  - **다) 애플리케이션 개발**<br/><br/>
    - PC에서 구동되는 애플리케이션 뿐만 아니라 모바일 웹 기반 플랫폼에서 구동되는 애플리케이션 개발 등 다양한 분야에서 활용된다.<br/><br/>
      - **애플리케이션이란?**<br/>응용 프로그램과 동의어로, OS 위에 설치된 소프트웨어 프로그램이다. <br/>Ex> MS Word, Power Point(PPT), 롤 등 특정 작업을 수행하기 위한 SW<br/><br/>
  - **라) 데이터베이스**<br/><br/>
    - 자바스크립트를 데이터베이스 처리용도로 사용할 수 있다. 대표적인 예로 JSON을 들 수 있다. <br/><br/>
  - **마) IoT**<br/><br/>
    - IoT 기반 환경의 프로그래밍에서도 자바스크립트를 활용할 수 있다. 라즈베리파이를 이용해서 집에 전등을 켜는 등의 사물통신을 자바스크립트 코드로 만들 수 있다.

  ### **2) CSS(Cascading Style Sheets)**
  - 정의:<br/>HTML, XML과 같은 **문서의 스타일을 꾸미기 위해 사용**하는 스타일리스트 언어이다.<br/><br/>
    - **CSS**가 중요한 이유는 현대 서비스 시장에서는 기술의 수준도 중요하지만 그 기술에 인기가 좋은 색깔이나 형태를 입힘으로써 **의미와 가치를 부여**하기 때문이다. <br/><br/>
  - CSS의 장단점

|구분|특성|설명|
|:--:|:--:|:--|
|  |확장성|- HTML 언어 요소에 다양한 기능을 추가(폰트 사이즈, 줄 간격, 색깔, 효과 등)<br/>- W3C에서 웹 표준으로 정의|
|장점|모듈화|- 디자인(CSS)과 정보(HTML 웹 코드)의 분리로 프로그래밍이 효율적<br/>- 전체 웹 페이지를 통일감 있게 구성할 수 있음|
|  |간편성|- 문서 형식을 이해하기 쉬움<br/>- 문서의 위치나 효과 등도 자유롭고 편하게 사용|
|단점|호환성|- 웹 브라우저와의 호환성 문제가 발생할 수 있음|
|  |

### **3) XML(eXtensible Markup Language)**
- 정의:<br/>XML은 W3C에서 개발된 **마크업 언어**이다. XML은 **다양한 표현성을 웹에서 구현**할 수 있다는 SGML 언어의 장점과 **다양한 활용성**을 가지고 있는 HTML의 장점을 모두 가지고 있으며, **데이터를 알맞게 태깅하고 분류 및 교환**하기 위해 사용하고 있는 <br/>표준 포멧이다.<br/>HTML이 웹 브라우저에서 문서를 단순히 보여주는 기능을 한다면, XML은 **정보를 태그로 표현**하여 특정 태그 안의 텍스트를 파란색으로 처리하는 등의 동적인 기능을 처리할 수 있다.<br/>Ex> 가끔 웹 페이지의 디자인이 누락되고 파란 태그와 함께 여러 문자열이 나열된 페이지가 출력될 때 보이는 것.<br/><br/>
  - **마크업 언어란?**<br/>바이너리 파일이 가지고 있는 **정보 저장성과 텍스트 파일의 교환성**을 찾기 위해 고안되었으며 **메타 데이터를 추가할 수 있는 텍스트 기반 언어**이다.<br/><br/>
- XML 특징

|특성|설명|
|:--:|:--|
|단순성|일반 text로 구성되어 있기 때문에 쉽게 판독 가능하며, 특정 하드웨어나 소프트웨어로부터 독립적이다.|
|표준성|W3C가 표준을 주도한다.|
|구조성|데이터를 설명하는 의미인 태그를 제공하고 특정 구조를 저장한다.|
|확장성|사용자 임의대로 태그 생성 및 확장이 가능|
|스타일 시트|XML 문서 작성을 위한 표준 스타일 시트 언어인 XSL이 있으며 논리적인 구조를 작성할 수 있음|
||

- XML 문서 작성절차

|단계|설명|
|:--|:---|
|1. 문서 유형 결정| - 작성을 하려는 XML 문서 유형을 결정|
|2. 문서 분석| - XML 문서 사용 용도 결정<br/>- XML 문서 논리적 구조와 요소들을 결정|
|3. DTD 작성| - 스키마를 정의하여 데이터베이스와 상호 연동이 되도록 함|
|4. XML 문서 작성| - DTD에 정의된 태그를 사용해서 XML 문서를 작성|
|5. XLS(Style Sheet) 작성| - XML 문서의 외형과 내용에 대한 절차를 작성|
||

### **4) HTML5**
- 정의:<br/>HTML5는 HTML의 새로운 버전이라고 할 수 있는데, 차세대 웹 표준으로 확정되었다.<br/><br/>
- 특징:<br/>텍스트와 하이퍼링크만 표시했던 기존 HTML과 달리 **멀티미디어, 그래픽 등 다양한 애플리케이션을 별도의 플러그인 없이도 제공**한다. 또한, 기존 HTML만으로 웹 서비스를 구성하기 불가능했으나 HTML5는 클라이언트-서버 통신이 가능해지면서<br/> **웹 서비스를 제공할 수 있도록 많은 기능이 추가**되었다.<br/><br/>
  - 장점:<br/>1. 액티브엑스의 문제점을 극복하여 음악이나 동영상 재생등과 같은 멀티미디어 기능의 자체적인 지원.<br/><br/>2. HTML5 표준 웹 환경이 확산되면 어떤 브라우저를 사용해도 인터넷에 접근 가능.<br/><br/>3. 운영체제 / 벤터 / 기기 상의 제약에서 벗어나 생태계가 활성화되고 개방화될 수 있다.<br/><br/>4. HTML은 웹 표준에 없는 비디오 등의 기능을 지원하려면 별도의 프로그램을 설치해야 하지만 HTML5에서는 웹 표준에 다양한 기능이 있어 별도 프로그램 설치 불필요.<br/><br/>
  - 단점: <br/>1. 일부 구형 브라우저에선 HTML5를 지원하지 않기 때문에 호환성에 문제가 생긴다. 끝

- HTML5 주요 기능

| 기능 | 설명 | 관련 표준 |
|:----:|:-----|:--------:|
|웹 폼<br/>(Web Form)| - 웹 페이지에서 사용자 입력을 받는 형식<br/>- 로그인 또는 검색 부분을 표현할 때 사용|HTML5|
|캔버스(Canvas)| - 스크립트(보통 JavaScript)를 통해 즉시 2차원 그래픽을 그릴 때 사용|Canvas 2D API, HTML Canvas 2D Context|
|SVG<br/>(Scalable Vector Graphics)| - 2차원 그래픽을 표현하기 위해 만들어진 XML 형식의 마크업 언어|HTML5|
|Video / Audio| - 웹 페이지 내 동영상 / 사운드를 임베드(embed)하는 것을 지원 | HTML5|
|Geolocation| - GPS정보 제공(디바이스에서 활용) | Geolocation |
|Offline Web Application| - 오프라인에서도 웹 애플리케이션이 정상 동작하도록 지원 | MTML5, Web SQL Database|
|Web SQL DB| - 데이터베이스로 SQL 쿼리를 할 수 있는 API | Web SQL Database|
|Local Storage| - 웹 클라이언트에서 키-쌍으로 구성된 데이터를 저장하는 기능 | Web Storage|
|WebSocket| - 웹 애플리케이션-서버 간 직접적인 양방향 통신을 위한 API | The WebSockket API|
|Web Worker| - 웹 페이지가 웹 애플리케이션과 함께 동작하도록 하며, 멀티스레드 구현이 가능하게 해주는 API|Web Workers|
||

### **5) PHP(Hypertext Preprocessor PHP)**
- 정의:<br/> 전 세계적 통계에서 언어 사용 비율 80%로 웹 프로그래밍에 가장 많이 사용되는 언어 중 하나이며, 정적인 HTML과 달리 사용자와 상호 작용하는 동적인 웹 페이지를 만들 수 있다.<br/><br/>
- PHP의 장단점

|장점|단점|
|:--|:---|
|- 오픈소스로 무료로 사용 가능|- 코드가 복잡해지고 웹 사이트가 커질수록 개발에 비효율적|
|- 컴파일이 필요 없어 속도가 빠름|- 코드 가독성이 떨어지며 유지보수가 용이하지 않음|
|- 운영체제와 Apache 등 대부분의 웹 서버에서 지원|- 다른 웹 언어에 비해 보안에 안전하지 않음<br/>(PHP 기반 프로그램들의 취약성이 계속 발견됨)|
|- 다른 웹 언어보다 코드가 직관적이며, 코드 양이 적음| |
|- HTML 문서 처리에 적합| |
|- 디버깅에 편함| |
|- 다양한 라이브러리 제공<br/>(XML 파싱, LDAP 등 다양한 프로토콜 지원)|
| |

 - PHP 동작 구조

        1. 클라이언트가 웹 브라우저로 서버에 php(로 작성된 웹 페이지)를 요청
        2. 웹 서버는 PHP 파서에 처리 요청
        3. PHP 파서는 데이터베이스에 연결하여 데이터 처리
        4. PHP 파서가 웹 서버에게 요청 처리 응답을 전달
        5. 웹 서버는 전달받은 데이터로 웹 페이지를 생성해서 클라이언트에게 응답

- 발전:<br/>PHP는 웹 개발에 많은 장점을 지녔지만 명확한 단점으로 인해 관리가 힘든 언어로 평가받는다.<br/> 그러나, PHP를 완전히 버리지 않고 한계점을 보완하는 방식으로 **HACK**이라는 언어를 개발하여 이용하고 있다.

### **6) ASP(Active Server Page) / ASP . NET**
- 정의:<br/>ASP는 인터넷 정보 서비스(IIS)에서 개발한 언어로, **웹 페이지 생성 용도로 사용**하기 위한 서버 사이드 스크립트 언어이며<br/> **윈도우 IIS 서버에서만 기능을 제공**하고 있다. = 윈도우 운영체제에서만 ASP로 웹을 개발할 수 있다.<br/>ASP와 ASP . NET은 IIS에서 처리 가능한 대표적인 웹 응용 애플리케이션 언어이다.<br/><br/>
  - **IIS의 기능**:<br/>IIS를 이용하면 **데이터베이스와 연동**되는 웹 응용 애플리케이션을 **작성**해서 **구동**시킬 수 있으며 FTP / SMTP / HTTP / HTTPS를 포함한 다양한 프로토콜을 처리할 수 있다.<br/><br/>
- ASP와 ASP . NET의 특징 비교

|ASP|ASP . NET|
|:--|:--------|
|스크립트 언어|**객체 지향 언어**|
|컴파일 필요 없음<br/>(인프리터)|컴파일 필요|
|- 상대적으로 쉽게 코드 작성 가능<br/>- VBScript를 활용하여 코드 작성|C#, J#, VB . net 등의 .net 언어로 작성 가능<br/>(비쥬얼 스튜디오로 개발 필요)|
|안정성과 확장성이 낮음|안정성과 확장성이 좋음|
|확장자는 .asp|확장자는 .aspx|
|IIS에서만 운영 가능|IIS와 .NET Framework에서 운영 가능|
|간단한 웹 페이지 개발에 적합|중대형 이상의 웹 페이지 개발에 적합|
||
- ASP 동작 구조

      1. 사용자가 웹 브라우저를 이용해서 IIS 서버에서 구동 중인 asp 페이지를 요청한다.
      2. IIS 서버는 asp 코드를 해석하기 위해 ASP.DLL을 실행시킨 다음 asp 페이지의 해석을 요청한다.
      3. ASP.DLL은 HTML로 작성된 결과를 IIS에 응답한다.
      4. IIS는 수신받은 html을 해석해서 클라이언트에게 응답한다.

### **7) JSP(Java Server Page)**
- 정의:<br/>JSP는 자바 언어를 기반으로 하는 서버 사이드 스크립트 언어이다.<br/><br/>
- JSP의 장단점

|장점|단점|
|:---|:---|
|오라클에서 지속적인 자바 소프트웨어 플랫폼 지원|비용이 많이 소요됨|
|자바 기반으로 다양한 API와 JDBC 사용 가능|개발시간이 오래 걸림|
|리눅스 / 윈도우에서 모두 사용 가능|메모리 누수 현상 예방 등 세밀한 관리가 필요|
|대규모 웹 사이트 구축에 적합(많은 사용자 접속 처리에 용이)| |
||
- JSP 동작 구조

        1. 클라이언트가 웹 브라우저로 서버에 Book.jsp 파일을 요청
        2. 서버는 JSP 컨테이너에 처리를 요청하고 JSP 컨테이너는 Book.jsp 파일을 찾아서 로드
        3. JSP 컨테이너가 Book.jsp 파일을 자바 서블릿(Servlet) 파일인 BookServlet.java 파일로 변환
        4. BookServlet.java 파일을 실행 가능한 BookServlet.class 파일로 컴파일
        5. 메모리에 BookServlet.class 파일을 적재하고 실행 결과를 서버로 반환
        6. 서버는 클라이언트의 웹 브라우저가 인식할 수 있는 페이지를 구성해서 응답

- 서블릿의 특징:<br/>1. 자바로 작성되었다. <br/>2. 자바코드 안에 HTML이 포함되며 확장자는 .java이다.<br/>3. 서버에서 웹 페이지 등을 동적으로 데이터를 처리하기 위해 많이 사용된다.

- 서블릿(Servlet)의 동작 구조

        1. 사용자가 웹 브라우저를 이용해서 웹 페이지를 요청한다.
        2. WAS(Web Applicaion Server)가 서블릿 코드를 수행해서 요청을 처리한다.
        3. WAS는 서블릿 컨테이너로 요청을 전송한다.
        4. 서블릿 컨테이너는 요청받은 java 파일을 class 파일로 컴파일하고, class 파일을 메모리상에 적재하여 메모리에서 서블릿 객체를 생성한다.
        5. HTTP 요청 시에 사용한 메소드에 따라 doGet() 혹은 doPost()함수를 호출한다.

  - 서블릿 컨테이너의 기능:<br/>1. 서블릿을 관리하는 컴포넌트이기 때문에 **HTTP 요청 시 java 파일을 .class 파일로 컴파일**하는 과정부터 시작해서 **서블릿 실행 결과를 사용자 브라우저에 전달**하기 위한 기능을 처리한다.<br/><br/>2. 사용자 요청에 따라 서블릿의 생명 주기를 관리해주는 기능을 수행한다.<br/><br/>3. 사용자가 HTTP 요청할 때마다 멀티 스레딩 기술을 사용해서 동시에 많은 요청을 처리한다.<br/><br/>4. 사용자가 HTTP 프로토콜로 GET이나 POST 메소드를 사용할 때 doGet() 또는 doPost() 메소드를 사용해서 사용자 입력 값을 받아 서버에 데이터를 전달한다.<br/>- doGet() 메소드는 URL 파라미터에서 데이터를 받고, doPost() 메소드는 데이터를 Body 영역에서 받는다. <br/>이러한 이유로 doPost() 메소드가 **데이터 전송에 제한이 없고 보안에 상대적으로 안전**하기 때문에 주로 사용된다.

- 서블릿과 JSP의 특징

|서블릿|JSP|
|:----|:---|
|자바코드로 구현<br/> (자바 지식 필요)|배우기 쉬움|
|HTML 태그로 문자열 처리|자바코드를 <% %> 태그 안에서 작성|
|코드 수정이 다소 어려우며, 컴파일 필요|페이지 요청 시 최초에 한 번만 자바코드로 변환 된 후 컴파일 한다.|
|주로 **동적**인 부분 처리|주로 **정적**인 부분 처리|
|사용자 뷰 구현과 프로그램 로직제어에 사용|주로 사용자용 뷰 구현에 사용|
||

- **MVC 패턴**
  - 등장 배경:<br/>초창기 JSP를 이용한 웹 애플리케이션 개발이 유행이였지만 기능이 추가될수록 코드를 유지보수하기 어려운 단점이 발생했다. 이러한 단점을 극복하기 위해 **MVC 패턴**이 등장하였고, 사용자 인터페이스와 개발 로직을 분리하여 유지 보수가 쉽도록 개선하였다.<br/><br/>
  - MAC 패턴 기본 구조:<br/>사용자가 Controller에게 데이터 입력 -> Controller는 Model 영역이 DB를 통해 데이터를 받아오게 함 -> View를 제어하여 사용자에게 결과 화면을 보여줌

|요소|설명|
|:--:|:---|
|Model|백그라운드에서 데이터를 처리하기 위해 **DB와 연동되는 영역**|
|View|사용자에게 결과 데이터를 출력해서 보여주는 화면 영역|
|Controller|사용자의 입력에 따라 **데이터의 처리를 위해 시스템을 제어**하는 영역|

- **MVC패턴 - Model 1 방식**

  - 요약:<br/>JSP에서 사용자의 요청을 모두 처리하는 구조. JSP 코드에서 뷰 코드와 자바코드를 통해 처리한다.

        1. 사용자 웹 브라우저에서 JSP를 요청 
        2. JSP는 JavaBeans를 사용해 데이터베이스와 통신하고 데이터를 처리 
        3. 결과를 사용자에게 출력
  - Model 1은 구조가 단순하여 간단한 페이지를 만드는 데 편리하지만, View와 로직 처리를 위한 자바 코드가 섞이기 때문에 JSP 코드 자체가 복잡해지므로 코드가 많아질수록 유지보수가 어렵다.<br/>그러한 이유로 현재는 Model 2 방식을 많이 사용하고 있다.

- **MVC패턴 - Model 2 방식**

  - 요약:<br/>JSP와 서블릿이 역할을 나누어서 사용자 요청을 처리한다.

        1. 사용자가 웹 브라우저에서 WAS로 JSP를 요청
        2. 서블릿 / 필터(Controller)가 요청을 받고 JavaBeans를 사용해 데이터베이스와 통신하고 데이터를 처리
        3. JavaBeans에서 가공한 데이터를 JSP(View)에 적용하고 서블릿 / 필터(Controller)가 해당 결과(View)를 사용자 브라우저에 전송한다.(응답)

  - 추가 설명:<br/>**JSP**는 HTML 사용이 편하고 자바코드 사용이 불편하기 때문에 웹 애플리케이션 구조에서 **사용자에게 결과를 보여주는 뷰(View)를 담당**한다.<br/>**서블릿**은 자바코드 작성이 편리하므로 **뷰와 통신하며 자료(사용자의 요청 정보)를 받아 가공하고 처리 결과를 사용자에게 응답**하는 컨트롤러의 역할을 한다.<br/><br/>
  - 한계:<br/>웹 사이트가 대규모일 때는 Model 2가 1에 비해 부담이 적어 용이하지만, 소규모 웹 사이트를 개발하는데 2보다 저렴한 1이 더 적합할 수 있다. <br/>소규모 웹 사이트 개발 시 구조가 단순하고 코드 작성이 쉬운 1 방식이 편하기 때문이다.<br/><br/><br/>

### **웹 서버 / WAS / DB의 이해**
- **웹 서버**:<br/>사용자가 웹 브라우저 등을 통해 HTTP(S)와 같은 프로토콜로 데이터를 요청했을 떄, 데이터를 처리한 다음 사용자에게 결과를 HTML 형태로 응답해주는 역할을 한다.<br/>웹 서버는 PHP, JSP, ASP와 같은 서버 사이드 언어를 지원하며, 데이터베이스와의 연동을 통해 데이터를 조회하고 수정한다.<br/>웹 서버는 서버 사이드 언어를 지원하기 위해서 필요한 Apache, nginx, Java, WebtoB, IIS 등의 웹 애플리케이션이 필요하다.<br/><br/>
  - **웹 애플리케이션이란?** 
    - **OS 위에 설치된 특정한 일을 수행하기 위해 만들어진 SW**로, MS Word나 롤 등의 게임을 예로 들 수 있다. <br/>Apache, Java, IIS 같은 웹 어플리케이션은 **여러가지 서버 사이드 언어를 지원**하며 자신의 웹 어플리케이션을 이용하여 서버 사이드 언어로 웹을 개발하면 자신이 가지고 있는 **서비스를 지원**해준다.<br/>(Ex> 웹이 데이터베이스에 접근하도록 하는 등)<br/><br/>

  - **CGI**
    - Common Gateway Interface의 약자로, 웹 서버와 사용자 간에 데이터 처리와 조회를 가능하게 하는 웹 인터페이스 프로그램이다. <br/>Ex> 사용자가 웹 사이트에 데이터를 요청 -> 웹 서버는 CGI에게 데이터를 넘겨 처리하도록 명령 -> CGI는 데이터를 처리하고 결과를 받아 사용자에게 전송<br/><br/>
    - 단점:<br/>CGI는 사용자의 요청에 따라 독립적인 프로세스를 사용하는 것이 가장 큰 단점이다.<br/>Ex> 사용자가 10건의 데이터를 요청했을 때 1개의 CGI가 생성되는 것이 아닌 10개의 CGI가 생성되어 시스템의 부하가 커진다.<br/><br/>
- **WAS**
    - CGI의 단점을 극복하기 위해 개발된 웹 애플리케이션 서버이다. <br/>WAS는 웹 애플리케이션이 동작할 수 있도록 지원하며 동적인 기능을 수행하는 페이지를 표현할 수 있다.<br/>데이터 처리를 위한 로직이 동작하는 서버이며, 사용자가 웹 브라우저로 요청한 데이터를 처리하고 사용자에게 결과를 응답하는 역할을 한다.<br/>이처럼 WAS는 웹 서버가 직접 프로그램을 호출하기 보다는 애플리케이션 서버를 별도로 두고 간접적으로 웹 애플리케이션을 실행한다.<br/><br/>
    - **웹 서버와 WAS를 분리해서 쓰는 이유는**?<br/><br/>
      - 웹 서버와 WAS는 기능적으로 봤을 때 목적이 다르기 때문이다.<br/>**웹 서버**: 정적인 데이터를 처리<br/>**WAS**: 동적인 데이터를 처리<br/><br/>이렇게 기능을 분배하는 것이 서버의 부담을 줄여주기도 하고 처리 속도에도 효율적이다. <br/>**웹 서버**는 주로 캐시 기능이나 프록시 기능 등 웹 클라이언트와 직접 연관된 일을 처리하고, <br/>**WAS**는 애플리케이션과 관련된 기능 및 데이터베이스와의 통신을 수행한다.<br/><br/>
      - 기능적인 목적 뿐만 아니라 보안적인 측면에서도 웹 서버와 WAS를 분리하는 것이 좋다. <br/>웹 서버에 웹쉘 업로드 등의 침해가 내부 시스템 영역으로 확장되는 것을 예방할 수 있기 때문이다.<br/><br/>

- **앱 - WAS 구조**
  - 가장 많이 사용하는 구조는 Apache - Tomcat이다. <br/><br/>
    - **Apache**:<br/>이미지나 단순 HTML 파일 같은 **정적인 데이터를 처리**할 수 있고, 다양한 모듈이 많아서 **웹 서버로 사용**하는 대표적인 애플리케이션이다.<br/><br/>
    - **Tomcat**:<br/>WAS 서버로 동작하며 Apache와의 통신을 통해 다양한 기능을 컨테이너에 구현하고 수행할 수 있다.<br/>컨테이너는 클라이언트가 웹 브라우저를 통해 요청 패킷을 송신하면 데이터를 처리하고 응답해주는 역할을 한다.